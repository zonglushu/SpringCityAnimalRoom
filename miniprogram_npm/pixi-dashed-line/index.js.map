{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexports.__esModule = true;\nexports.DashLine = void 0;\nvar PIXI = require(\"pixi.js\");\nvar dashLineOptionsDefault = {\n    dash: [10, 5],\n    width: 1,\n    color: 0xffffff,\n    alpha: 1,\n    scale: 1,\n    useTexture: false,\n    alignment: 0.5\n};\nvar DashLine = /** @class */ (function () {\n    /**\n     * Create a DashLine\n     * @param graphics\n     * @param [options]\n     * @param [options.useTexture=false] - use the texture based render (useful for very large or very small dashed lines)\n     * @param [options.dashes=[10,5] - an array holding the dash and gap (eg, [10, 5, 20, 5, ...])\n     * @param [options.width=1] - width of the dashed line\n     * @param [options.alpha=1] - alpha of the dashed line\n     * @param [options.color=0xffffff] - color of the dashed line\n     * @param [options.cap] - add a PIXI.LINE_CAP style to dashed lines (only works for useTexture: false)\n     * @param [options.join] - add a PIXI.LINE_JOIN style to the dashed lines (only works for useTexture: false)\n     * @param [options.alignment] - The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner)\n     */\n    function DashLine(graphics, options) {\n        if (options === void 0) { options = {}; }\n        /** cursor location */\n        this.cursor = new PIXI.Point();\n        /** desired scale of line */\n        this.scale = 1;\n        this.graphics = graphics;\n        options = __assign(__assign({}, dashLineOptionsDefault), options);\n        this.dash = options.dash;\n        this.dashSize = this.dash.reduce(function (a, b) { return a + b; });\n        this.useTexture = options.useTexture;\n        this.options = options;\n        this.setLineStyle();\n    }\n    /** resets line style to enable dashed line (useful if lineStyle was changed on graphics element) */\n    DashLine.prototype.setLineStyle = function () {\n        var options = this.options;\n        if (this.useTexture) {\n            var texture = DashLine.getTexture(options, this.dashSize);\n            this.graphics.lineTextureStyle({\n                width: options.width * options.scale,\n                color: options.color,\n                alpha: options.alpha,\n                texture: texture,\n                alignment: options.alignment\n            });\n            this.activeTexture = texture;\n        }\n        else {\n            this.graphics.lineStyle({\n                width: options.width * options.scale,\n                color: options.color,\n                alpha: options.alpha,\n                cap: options.cap,\n                join: options.join,\n                alignment: options.alignment\n            });\n        }\n        this.scale = options.scale;\n    };\n    DashLine.distance = function (x1, y1, x2, y2) {\n        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    };\n    DashLine.prototype.moveTo = function (x, y) {\n        this.lineLength = 0;\n        this.cursor.set(x, y);\n        this.start = new PIXI.Point(x, y);\n        this.graphics.moveTo(this.cursor.x, this.cursor.y);\n        return this;\n    };\n    DashLine.prototype.lineTo = function (x, y, closePath) {\n        if (typeof this.lineLength === undefined) {\n            this.moveTo(0, 0);\n        }\n        var length = DashLine.distance(this.cursor.x, this.cursor.y, x, y);\n        var angle = Math.atan2(y - this.cursor.y, x - this.cursor.x);\n        var closed = closePath && x === this.start.x && y === this.start.y;\n        if (this.useTexture) {\n            this.graphics.moveTo(this.cursor.x, this.cursor.y);\n            this.adjustLineStyle(angle);\n            if (closed && this.dash.length % 2 === 0) {\n                var gap = Math.min(this.dash[this.dash.length - 1], length);\n                this.graphics.lineTo(x - Math.cos(angle) * gap, y - Math.sin(angle) * gap);\n                this.graphics.closePath();\n            }\n            else {\n                this.graphics.lineTo(x, y);\n            }\n        }\n        else {\n            var cos = Math.cos(angle);\n            var sin = Math.sin(angle);\n            var x0 = this.cursor.x;\n            var y0 = this.cursor.y;\n            // find the first part of the dash for this line\n            var place = this.lineLength % (this.dashSize * this.scale);\n            var dashIndex = 0, dashStart = 0;\n            var dashX = 0;\n            for (var i = 0; i < this.dash.length; i++) {\n                var dashSize = this.dash[i] * this.scale;\n                if (place < dashX + dashSize) {\n                    dashIndex = i;\n                    dashStart = place - dashX;\n                    break;\n                }\n                else {\n                    dashX += dashSize;\n                }\n            }\n            var remaining = length;\n            // let count = 0\n            while (remaining > 0) { // && count++ < 1000) {\n                var dashSize = this.dash[dashIndex] * this.scale - dashStart;\n                var dist = remaining > dashSize ? dashSize : remaining;\n                if (closed) {\n                    var remainingDistance = DashLine.distance(x0 + cos * dist, y0 + sin * dist, this.start.x, this.start.y);\n                    if (remainingDistance <= dist) {\n                        if (dashIndex % 2 === 0) {\n                            var lastDash = DashLine.distance(x0, y0, this.start.x, this.start.y) - this.dash[this.dash.length - 1] * this.scale;\n                            x0 += cos * lastDash;\n                            y0 += sin * lastDash;\n                            this.graphics.lineTo(x0, y0);\n                        }\n                        break;\n                    }\n                }\n                x0 += cos * dist;\n                y0 += sin * dist;\n                if (dashIndex % 2) {\n                    this.graphics.moveTo(x0, y0);\n                }\n                else {\n                    this.graphics.lineTo(x0, y0);\n                }\n                remaining -= dist;\n                dashIndex++;\n                dashIndex = dashIndex === this.dash.length ? 0 : dashIndex;\n                dashStart = 0;\n            }\n            // if (count >= 1000) console.log('failure', this.scale)\n        }\n        this.lineLength += length;\n        this.cursor.set(x, y);\n        return this;\n    };\n    DashLine.prototype.closePath = function () {\n        this.lineTo(this.start.x, this.start.y, true);\n    };\n    DashLine.prototype.drawCircle = function (x, y, radius, points, matrix) {\n        if (points === void 0) { points = 80; }\n        var interval = Math.PI * 2 / points;\n        var angle = 0, first;\n        if (matrix) {\n            first = new PIXI.Point(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);\n            matrix.apply(first, first);\n            this.moveTo(first[0], first[1]);\n        }\n        else {\n            first = new PIXI.Point(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);\n            this.moveTo(first.x, first.y);\n        }\n        angle += interval;\n        for (var i = 1; i < points + 1; i++) {\n            var next = i === points ? first : [x + Math.cos(angle) * radius, y + Math.sin(angle) * radius];\n            this.lineTo(next[0], next[1]);\n            angle += interval;\n        }\n        return this;\n    };\n    DashLine.prototype.drawEllipse = function (x, y, radiusX, radiusY, points, matrix) {\n        if (points === void 0) { points = 80; }\n        var interval = Math.PI * 2 / points;\n        var first;\n        var point = new PIXI.Point();\n        var f = 0;\n        for (var i = 0; i < Math.PI * 2; i += interval) {\n            var x0 = x - radiusX * Math.sin(i);\n            var y0 = y - radiusY * Math.cos(i);\n            if (matrix) {\n                point.set(x0, y0);\n                matrix.apply(point, point);\n                x0 = point.x;\n                y0 = point.y;\n            }\n            if (i === 0) {\n                this.moveTo(x0, y0);\n                first = { x: x0, y: y0 };\n            }\n            else {\n                this.lineTo(x0, y0);\n            }\n        }\n        this.lineTo(first.x, first.y, true);\n        return this;\n    };\n    DashLine.prototype.drawPolygon = function (points, matrix) {\n        var p = new PIXI.Point();\n        if (typeof points[0] === 'number') {\n            if (matrix) {\n                p.set(points[0], points[1]);\n                matrix.apply(p, p);\n                this.moveTo(p.x, p.y);\n                for (var i = 2; i < points.length; i += 2) {\n                    p.set(points[i], points[i + 1]);\n                    matrix.apply(p, p);\n                    this.lineTo(p.x, p.y, i === points.length - 2);\n                }\n            }\n            else {\n                this.moveTo(points[0], points[1]);\n                for (var i = 2; i < points.length; i += 2) {\n                    this.lineTo(points[i], points[i + 1], i === points.length - 2);\n                }\n            }\n        }\n        else {\n            if (matrix) {\n                var point = points[0];\n                p.copyFrom(point);\n                matrix.apply(p, p);\n                this.moveTo(p.x, p.y);\n                for (var i = 1; i < points.length; i++) {\n                    var point_1 = points[i];\n                    p.copyFrom(point_1);\n                    matrix.apply(p, p);\n                    this.lineTo(p.x, p.y, i === points.length - 1);\n                }\n            }\n            else {\n                var point = points[0];\n                this.moveTo(point.x, point.y);\n                for (var i = 1; i < points.length; i++) {\n                    var point_2 = points[i];\n                    this.lineTo(point_2.x, point_2.y, i === points.length - 1);\n                }\n            }\n        }\n        return this;\n    };\n    DashLine.prototype.drawRect = function (x, y, width, height, matrix) {\n        if (matrix) {\n            var p = new PIXI.Point();\n            // moveTo(x, y)\n            p.set(x, y);\n            matrix.apply(p, p);\n            this.moveTo(p.x, p.y);\n            // lineTo(x + width, y)\n            p.set(x + width, y);\n            matrix.apply(p, p);\n            this.lineTo(p.x, p.y);\n            // lineTo(x + width, y + height)\n            p.set(x + width, y + height);\n            matrix.apply(p, p);\n            this.lineTo(p.x, p.y);\n            // lineto(x, y + height)\n            p.set(x, y + height);\n            matrix.apply(p, p);\n            this.lineTo(p.x, p.y);\n            // lineTo(x, y, true)\n            p.set(x, y);\n            matrix.apply(p, p);\n            this.lineTo(p.x, p.y, true);\n        }\n        else {\n            this.moveTo(x, y)\n                .lineTo(x + width, y)\n                .lineTo(x + width, y + height)\n                .lineTo(x, y + height)\n                .lineTo(x, y, true);\n        }\n        return this;\n    };\n    // adjust the matrix for the dashed texture\n    DashLine.prototype.adjustLineStyle = function (angle) {\n        var lineStyle = this.graphics.line;\n        lineStyle.matrix = new PIXI.Matrix();\n        if (angle) {\n            lineStyle.matrix.rotate(angle);\n        }\n        if (this.scale !== 1)\n            lineStyle.matrix.scale(this.scale, this.scale);\n        var textureStart = -this.lineLength;\n        lineStyle.matrix.translate(this.cursor.x + textureStart * Math.cos(angle), this.cursor.y + textureStart * Math.sin(angle));\n        this.graphics.lineStyle(lineStyle);\n    };\n    // creates or uses cached texture\n    DashLine.getTexture = function (options, dashSize) {\n        var key = options.dash.toString();\n        if (DashLine.dashTextureCache[key]) {\n            return DashLine.dashTextureCache[key];\n        }\n        var canvas = document.createElement(\"canvas\");\n        canvas.width = dashSize;\n        canvas.height = Math.ceil(options.width);\n        var context = canvas.getContext(\"2d\");\n        if (!context) {\n            console.warn('Did not get context from canvas');\n            return;\n        }\n        context.strokeStyle = \"white\";\n        context.globalAlpha = options.alpha;\n        context.lineWidth = options.width;\n        var x = 0;\n        var y = options.width / 2;\n        context.moveTo(x, y);\n        for (var i = 0; i < options.dash.length; i += 2) {\n            x += options.dash[i];\n            context.lineTo(x, y);\n            if (options.dash.length !== i + 1) {\n                x += options.dash[i + 1];\n                context.moveTo(x, y);\n            }\n        }\n        context.stroke();\n        var texture = DashLine.dashTextureCache[key] = PIXI.Texture.from(canvas);\n        texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\n        return texture;\n    };\n    // cache of PIXI.Textures for dashed lines\n    DashLine.dashTextureCache = {};\n    return DashLine;\n}());\nexports.DashLine = DashLine;\n//# sourceMappingURL=index.js.map"]}